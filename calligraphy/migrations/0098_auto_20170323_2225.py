# -*- coding: utf-8 -*-
# Generated by Django 1.10.3 on 2017-03-23 22:25
# 
#  Goes through and deletes all but the biggest character with a mark, if no mark then keeps biggest character
#
#
#############################################################################################################


from __future__ import unicode_literals

from django.db import migrations

class Overlap_ammount(object):
    def __init__(self, overlap_withs, overlap_degree):
        self.overlap_target = overlap_withs    #Char
        self.overlap_degree = overlap_degree # 0-1 fraction of overlap

class Char_xy(object):
    def __init__(self, parent, a, b):
        self.parent = parent
        self.a =  a
        self.b = b
        self.overlap_degree_and_target = []

class Char(object):
    def __init__(self, inChar):
        self.db_cur = inChar
        self.idd = inChar.id
        self.mark = inChar.mark
        self.x  = Char_xy(self, inChar.x1, inChar.x2)
        self.y = Char_xy(self, inChar.y1, inChar.y2)
        self.overlaps_with = []
        self.size = (inChar.x2 - inChar.x1) * (inChar.y2 - inChar.y1)
        

delete_list = []

def delete_duplicates(chars_sheet) -> None:
    chars_x = []
    chars_y = []
    for char in chars_sheet:
#        if char.mark == 'ç”Ÿ':
#            print(char.mark)
        chars_x.append(char.x)
        chars_y.append(char.y)
    chars_x.sort(key=lambda k: k.a)
    chars_y.sort(key=lambda k: k.a)
    
    NUM_CHARS = len(chars_sheet)


    for i in range(0, NUM_CHARS):
        for j in range(i + 1, NUM_CHARS):
            if chars_x[i].b >= chars_x[j].a:
                ammount = (chars_x[i].b - chars_x[j].a) / (chars_x[i].b - chars_x[i].a)
                o_ammount = Overlap_ammount(chars_x[j].parent, ammount)
                o_ammount2 = Overlap_ammount(chars_x[i].parent, ammount)
                chars_x[i].overlap_degree_and_target.append(o_ammount)
                chars_x[j].overlap_degree_and_target.append(o_ammount2)
            else:
               break

    for i in range(0, NUM_CHARS):
        for j in range(i + 1, NUM_CHARS):
            if chars_y[i].b >= chars_y[j].a:
                ammount = (chars_y[i].b - chars_y[j].a) / (chars_y[i].b - chars_y[i].a)
                o_ammount = Overlap_ammount(chars_y[j].parent, ammount)
                o_ammount2 = Overlap_ammount(chars_y[i].parent, ammount)
                chars_y[i].overlap_degree_and_target.append(o_ammount)
                chars_y[j].overlap_degree_and_target.append(o_ammount2)
            else:
                break
        
    for char_x in chars_x:
        for x_overlap_degree_and_target in char_x.overlap_degree_and_target:
            for y_overlap_degree_and_target in char_x.parent.y.overlap_degree_and_target:
                if x_overlap_degree_and_target.overlap_target is y_overlap_degree_and_target.overlap_target:
                    if x_overlap_degree_and_target.overlap_degree * y_overlap_degree_and_target.overlap_degree > .5:
                        char_x.parent.overlaps_with.append(x_overlap_degree_and_target.overlap_target)

    # Fix the ordered collections
    chars_sheet.sort(key=lambda k:k.size, reverse=True)
    for char in chars_sheet:
        at_least_one_mark = False
        if len(char.overlaps_with) > 0:
            char_stack = []
            char_stack.append(char)
            if not char.mark.isspace():
                at_least_one_mark = True
            for char_ovr in char.overlaps_with:
                if not char_ovr.mark.isspace():
                    at_least_one_mark = True
                char_stack.append(char_ovr)
            char_stack.sort(key=lambda k:k.size, reverse=True)
            delete_cascade = False;
            if(at_least_one_mark):
                for char_s in char_stack:
                    if char_s not in delete_list:
                        if delete_cascade:
                            delete_list.append(char_s)
                        else:
                            if not char_s.mark.isspace():
                                delete_cascade = True
                            else:
                                delete_list.append(char_s)
            else: # no marks
                for char_s in char_stack:
                    if char_s not in delete_list:
                        if delete_cascade:
                            delete_list.append(char_s)
                        else:
                            delete_cascade = True



def do_stuff(apps, schemd_editor) -> None:
    Chars      = apps.get_model('calligraphy', 'Character')
    Page       = apps.get_model('calligraphy', 'Page')
    for page in Page.objects.all():
        char_set = []
        for char in Chars.objects.filter(parent_page=page):
            char_set.append(Char(char))
        delete_duplicates(char_set)
    for dels in delete_list:
        dels.db_cur.delete()


class Migration(migrations.Migration):

    dependencies = [
        ('calligraphy', '0097_auto_20170323_2152'),
    ]

    operations = [ migrations.RunPython(do_stuff)
    ]
